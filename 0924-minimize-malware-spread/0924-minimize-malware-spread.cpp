class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& g, vector<int>& initial) {
        int n = g.size(), m = initial.size();
        vector<int> graph[n];
        for(int i = 0; i < n; ++i) {
            for(int j = 0; j < n; ++j) {
                if(i == j) continue;
                if(g[i][j] == 1) {
                    graph[i].push_back(j);
                    graph[j].push_back(i);
                }
            }
        }
        
        unordered_set<int>st;
        vector<int> vis(n, 0);
        for(int i = 0; i < m; ++i) {
            vis[initial[i]] = 1;
            st.insert(initial[i]);
        }
        
        int ans = 0, mn = 1e9;
        
        for(int i = 0; i < m; ++i) {
            vis[initial[i]] = 0;
            queue<int>q;
            for(int j = 0; j < m; ++j) {
                if(i != j) {
                    q.push(initial[j]);
                }
            }
            int cnt = 0;
            while(!q.empty()) {
                auto front = q.front();
                q.pop();
                cnt++;
                for(auto &adj : graph[front]) {
                    if(!vis[adj]) {
                        vis[adj] = 1;
                        q.push(adj);
                    }
                }
            }
            if(cnt < mn) {
                mn = cnt;
                ans = initial[i];
            } else if(cnt == mn) {
                if(ans > initial[i]) {
                    ans = initial[i];
                }
            }
            for(int j = 0; j < n; ++j) {
                if(st.count(j)) {
                    vis[j] = 1;
                } else {
                    vis[j] = 0;
                }
            }
        }
        return ans;
    }
};